[  0%] Built target sensor_msgs_generate_messages_nodejs
[  0%] Built target dynamic_reconfigure_generate_messages_nodejs
[  0%] Built target sensor_msgs_generate_messages_cpp
[  0%] Built target sensor_msgs_generate_messages_py
[  0%] Built target march_shared_msgs_generate_messages_py
[  0%] Built target march_shared_msgs_generate_messages_eus
[  0%] Built target march_shared_msgs_generate_messages_nodejs
[  0%] Built target roscpp_generate_messages_eus
[  0%] Built target roscpp_generate_messages_cpp
[  0%] Built target std_msgs_generate_messages_py
[  0%] Built target march_shared_msgs_generate_messages_cpp
[  0%] Built target control_toolbox_gencfg
[  0%] Built target std_msgs_generate_messages_nodejs
[  0%] Built target geometry_msgs_generate_messages_eus
[  0%] Built target roscpp_generate_messages_nodejs
[  0%] Built target std_msgs_generate_messages_cpp
[  0%] Built target actionlib_msgs_generate_messages_py
[  0%] Built target actionlib_generate_messages_cpp
[  0%] Built target march_shared_msgs_generate_messages_lisp
[  0%] Built target rosgraph_msgs_generate_messages_nodejs
[  0%] Built target rosgraph_msgs_generate_messages_lisp
[  0%] Built target actionlib_generate_messages_py
[  0%] Built target actionlib_generate_messages_lisp
[  0%] Built target _catkin_empty_exported_target
[  0%] Built target actionlib_generate_messages_nodejs
[  0%] Built target control_msgs_generate_messages_eus
[  0%] Built target trajectory_msgs_generate_messages_nodejs
[  0%] Built target trajectory_msgs_generate_messages_cpp
[  0%] Built target control_toolbox_generate_messages_py
[  0%] Built target rosgraph_msgs_generate_messages_py
[  0%] Built target std_msgs_generate_messages_eus
[  0%] Built target actionlib_msgs_generate_messages_nodejs
[  0%] Built target rosgraph_msgs_generate_messages_eus
[  0%] Built target actionlib_msgs_generate_messages_lisp
[  0%] Built target actionlib_msgs_generate_messages_cpp
[  0%] Built target sensor_msgs_generate_messages_lisp
[  0%] Built target control_msgs_generate_messages_cpp
[  0%] Built target sensor_msgs_generate_messages_eus
[  0%] Built target control_msgs_generate_messages_lisp
[  0%] Built target std_msgs_generate_messages_lisp
[  0%] Built target control_toolbox_generate_messages_nodejs
[  0%] Built target roscpp_generate_messages_lisp
[  0%] Built target actionlib_msgs_generate_messages_eus
[  0%] Built target dynamic_reconfigure_generate_messages_py
[  0%] Built target control_msgs_generate_messages_py
[  0%] Built target control_msgs_generate_messages_nodejs
[  0%] Built target geometry_msgs_generate_messages_cpp
[  0%] Built target geometry_msgs_generate_messages_lisp
[  0%] Built target trajectory_msgs_generate_messages_lisp
[  0%] Built target rosgraph_msgs_generate_messages_cpp
[  0%] Built target geometry_msgs_generate_messages_py
[  0%] Built target actionlib_generate_messages_eus
[  0%] Built target trajectory_msgs_generate_messages_py
[  0%] Built target trajectory_msgs_generate_messages_eus
[  0%] Built target control_toolbox_generate_messages_cpp
[  0%] Built target roscpp_generate_messages_py
[  0%] Built target control_toolbox_generate_messages_eus
[  0%] Built target control_toolbox_generate_messages_lisp
[  0%] Built target dynamic_reconfigure_generate_messages_cpp
[  0%] Built target geometry_msgs_generate_messages_nodejs
[  0%] Built target dynamic_reconfigure_generate_messages_eus
[  0%] Built target dynamic_reconfigure_gencfg
[  0%] Built target dynamic_reconfigure_generate_messages_lisp
[35m[1mScanning dependencies of target computed_torque_lib[0m
[ 50%] [32mBuilding CXX object CMakeFiles/computed_torque_lib.dir/src/computed_torque_controller.cpp.o[0m
In file included from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:32:1:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kinclude[m[Kâ€™ does not name a type
   32 | [01;31m[Kinclude[m[K <trajectory_interface/joint_trajectory_segment.h>
      | [01;31m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:148:62:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  148 | inline bool Equal(const Vector& a,const Vector& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                              [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:148:62:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:149:60:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  149 | inline bool Equal(const Frame& a,const Frame& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                            [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:149:60:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:150:60:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  150 | inline bool Equal(const Twist& a,const Twist& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                            [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:150:60:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:151:62:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  151 | inline bool Equal(const Wrench& a,const Wrench& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                              [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:151:62:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:152:64:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  152 | inline bool Equal(const Vector2& a,const Vector2& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                                [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:152:64:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:153:68:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  153 | inline bool Equal(const Rotation2& a,const Rotation2& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                                    [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:153:68:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:154:62:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  154 | inline bool Equal(const Frame2& a,const Frame2& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                              [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:154:62:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:237:34:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  237 |      double Normalize(double eps=[01;31m[Kepsilon[m[K);
      |                                  [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:237:34:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:387:45:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  387 |  double GetRotAngle(Vector& axis,double eps=[01;31m[Kepsilon[m[K) const;
      |                                             [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:387:45:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:557:63:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  557 |     bool Equal(const Rotation& a,const Rotation& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                               [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:557:63:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:1015:34:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
 1015 |      double Normalize(double eps=[01;31m[Kepsilon[m[K);
      |                                  [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:1015:34:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.inl:[m[K In member function â€˜[01m[Kvoid KDL::Frame::Integrate(const KDL::Twist&, double)[m[Kâ€™:
[01m[K/usr/include/kdl/frames.inl:622:11:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  622 |     if (n<[01;31m[Kepsilon[m[K) {
      |           [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:622:11:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.inl:[m[K In function â€˜[01m[Kbool KDL::Equal(const KDL::Vector&, const KDL::Vector&, double)[m[Kâ€™:
[01m[K/usr/include/kdl/frames.inl:1026:46:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KEqual(const double&, const double&, double&)[m[Kâ€™
 1026 |         return (Equal(a.data[0],b.data[0],eps[01;31m[K)[m[K&&
      |                                              [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1025:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector&, const KDL::Vector&, double)[m[Kâ€™
 1025 | IMETHOD bool [01;36m[KEqual[m[K(const Vector& a,const Vector& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1025:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
 1025 | IMETHOD bool Equal([01;36m[Kconst Vector& a[m[K,const Vector& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:706:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame&, const KDL::Frame&, double)[m[Kâ€™
  706 |      inline friend bool [01;36m[KEqual[m[K(const Frame& a,const Frame& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:149:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame&[m[Kâ€™
  149 | inline bool Equal([01;36m[Kconst Frame& a[m[K,const Frame& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:781:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Twist&, const KDL::Twist&, double)[m[Kâ€™
  781 |      inline friend bool [01;36m[KEqual[m[K(const Twist& a,const Twist& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:150:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Twist&[m[Kâ€™
  150 | inline bool Equal([01;36m[Kconst Twist& a[m[K,const Twist& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:944:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Wrench&, const KDL::Wrench&, double)[m[Kâ€™
  944 |      inline friend bool [01;36m[KEqual[m[K(const Wrench& a,const Wrench& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:151:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Wrench&[m[Kâ€™
  151 | inline bool Equal([01;36m[Kconst Wrench& a[m[K,const Wrench& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:1037:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector2&, const KDL::Vector2&, double)[m[Kâ€™
 1037 |      inline friend bool [01;36m[KEqual[m[K(const Vector2& a,const Vector2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:152:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector2&[m[Kâ€™
  152 | inline bool Equal([01;36m[Kconst Vector2& a[m[K,const Vector2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:1089:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation2&, const KDL::Rotation2&, double)[m[Kâ€™
 1089 |      inline friend bool [01;36m[KEqual[m[K(const Rotation2& a,const Rotation2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:153:36:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation2&[m[Kâ€™
  153 | inline bool Equal([01;36m[Kconst Rotation2& a[m[K,const Rotation2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:1130:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame2&, const KDL::Frame2&, double)[m[Kâ€™
 1130 |      inline friend bool [01;36m[KEqual[m[K(const Frame2& a,const Frame2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:154:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame2&[m[Kâ€™
  154 | inline bool Equal([01;36m[Kconst Frame2& a[m[K,const Frame2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:557:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation&, const KDL::Rotation&, double)[m[Kâ€™
  557 |     bool [01;36m[KEqual[m[K(const Rotation& a,const Rotation& b,double eps=epsilon);
      |          [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:547:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation&[m[Kâ€™
  547 |      friend bool Equal([01;36m[Kconst Rotation& a[m[K,const Rotation& b,double eps);
      |                        [01;36m[K~~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.inl:1027:46:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KEqual(const double&, const double&, double&)[m[Kâ€™
 1027 |                 Equal(a.data[1],b.data[1],eps[01;31m[K)[m[K&&
      |                                              [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1025:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector&, const KDL::Vector&, double)[m[Kâ€™
 1025 | IMETHOD bool [01;36m[KEqual[m[K(const Vector& a,const Vector& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1025:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
 1025 | IMETHOD bool Equal([01;36m[Kconst Vector& a[m[K,const Vector& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:706:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame&, const KDL::Frame&, double)[m[Kâ€™
  706 |      inline friend bool [01;36m[KEqual[m[K(const Frame& a,const Frame& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:149:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame&[m[Kâ€™
  149 | inline bool Equal([01;36m[Kconst Frame& a[m[K,const Frame& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:781:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Twist&, const KDL::Twist&, double)[m[Kâ€™
  781 |      inline friend bool [01;36m[KEqual[m[K(const Twist& a,const Twist& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:150:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Twist&[m[Kâ€™
  150 | inline bool Equal([01;36m[Kconst Twist& a[m[K,const Twist& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:944:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Wrench&, const KDL::Wrench&, double)[m[Kâ€™
  944 |      inline friend bool [01;36m[KEqual[m[K(const Wrench& a,const Wrench& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:151:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Wrench&[m[Kâ€™
  151 | inline bool Equal([01;36m[Kconst Wrench& a[m[K,const Wrench& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:1037:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector2&, const KDL::Vector2&, double)[m[Kâ€™
 1037 |      inline friend bool [01;36m[KEqual[m[K(const Vector2& a,const Vector2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:152:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector2&[m[Kâ€™
  152 | inline bool Equal([01;36m[Kconst Vector2& a[m[K,const Vector2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:1089:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation2&, const KDL::Rotation2&, double)[m[Kâ€™
 1089 |      inline friend bool [01;36m[KEqual[m[K(const Rotation2& a,const Rotation2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:153:36:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation2&[m[Kâ€™
  153 | inline bool Equal([01;36m[Kconst Rotation2& a[m[K,const Rotation2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:1130:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame2&, const KDL::Frame2&, double)[m[Kâ€™
 1130 |      inline friend bool [01;36m[KEqual[m[K(const Frame2& a,const Frame2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:154:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame2&[m[Kâ€™
  154 | inline bool Equal([01;36m[Kconst Frame2& a[m[K,const Frame2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:557:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation&, const KDL::Rotation&, double)[m[Kâ€™
  557 |     bool [01;36m[KEqual[m[K(const Rotation& a,const Rotation& b,double eps=epsilon);
      |          [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:547:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation&[m[Kâ€™
  547 |      friend bool Equal([01;36m[Kconst Rotation& a[m[K,const Rotation& b,double eps);
      |                        [01;36m[K~~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.inl:1028:46:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KEqual(const double&, const double&, double&)[m[Kâ€™
 1028 |                 Equal(a.data[2],b.data[2],eps[01;31m[K)[m[K   );
      |                                              [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1025:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector&, const KDL::Vector&, double)[m[Kâ€™
 1025 | IMETHOD bool [01;36m[KEqual[m[K(const Vector& a,const Vector& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1025:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
 1025 | IMETHOD bool Equal([01;36m[Kconst Vector& a[m[K,const Vector& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:706:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame&, const KDL::Frame&, double)[m[Kâ€™
  706 |      inline friend bool [01;36m[KEqual[m[K(const Frame& a,const Frame& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:149:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame&[m[Kâ€™
  149 | inline bool Equal([01;36m[Kconst Frame& a[m[K,const Frame& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:781:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Twist&, const KDL::Twist&, double)[m[Kâ€™
  781 |      inline friend bool [01;36m[KEqual[m[K(const Twist& a,const Twist& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:150:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Twist&[m[Kâ€™
  150 | inline bool Equal([01;36m[Kconst Twist& a[m[K,const Twist& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:944:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Wrench&, const KDL::Wrench&, double)[m[Kâ€™
  944 |      inline friend bool [01;36m[KEqual[m[K(const Wrench& a,const Wrench& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:151:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Wrench&[m[Kâ€™
  151 | inline bool Equal([01;36m[Kconst Wrench& a[m[K,const Wrench& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:1037:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector2&, const KDL::Vector2&, double)[m[Kâ€™
 1037 |      inline friend bool [01;36m[KEqual[m[K(const Vector2& a,const Vector2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:152:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector2&[m[Kâ€™
  152 | inline bool Equal([01;36m[Kconst Vector2& a[m[K,const Vector2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:1089:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation2&, const KDL::Rotation2&, double)[m[Kâ€™
 1089 |      inline friend bool [01;36m[KEqual[m[K(const Rotation2& a,const Rotation2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:153:36:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation2&[m[Kâ€™
  153 | inline bool Equal([01;36m[Kconst Rotation2& a[m[K,const Rotation2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:1130:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame2&, const KDL::Frame2&, double)[m[Kâ€™
 1130 |      inline friend bool [01;36m[KEqual[m[K(const Frame2& a,const Frame2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:154:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame2&[m[Kâ€™
  154 | inline bool Equal([01;36m[Kconst Frame2& a[m[K,const Frame2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:557:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation&, const KDL::Rotation&, double)[m[Kâ€™
  557 |     bool [01;36m[KEqual[m[K(const Rotation& a,const Rotation& b,double eps=epsilon);
      |          [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:547:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation&[m[Kâ€™
  547 |      friend bool Equal([01;36m[Kconst Rotation& a[m[K,const Rotation& b,double eps);
      |                        [01;36m[K~~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.inl:[m[K In function â€˜[01m[Kbool KDL::Equal(const KDL::Vector2&, const KDL::Vector2&, double)[m[Kâ€™:
[01m[K/usr/include/kdl/frames.inl:1048:46:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KEqual(const double&, const double&, double&)[m[Kâ€™
 1048 |         return (Equal(a.data[0],b.data[0],eps[01;31m[K)[m[K&&
      |                                              [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1025:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector&, const KDL::Vector&, double)[m[Kâ€™
 1025 | IMETHOD bool [01;36m[KEqual[m[K(const Vector& a,const Vector& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1025:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
 1025 | IMETHOD bool Equal([01;36m[Kconst Vector& a[m[K,const Vector& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1032:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame&, const KDL::Frame&, double)[m[Kâ€™
 1032 | IMETHOD bool [01;36m[KEqual[m[K(const Frame& a,const Frame& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1032:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame&[m[Kâ€™
 1032 | IMETHOD bool Equal([01;36m[Kconst Frame& a[m[K,const Frame& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1042:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Twist&, const KDL::Twist&, double)[m[Kâ€™
 1042 | IMETHOD bool [01;36m[KEqual[m[K(const Twist& a,const Twist& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1042:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Twist&[m[Kâ€™
 1042 | IMETHOD bool Equal([01;36m[Kconst Twist& a[m[K,const Twist& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1037:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Wrench&, const KDL::Wrench&, double)[m[Kâ€™
 1037 | IMETHOD bool [01;36m[KEqual[m[K(const Wrench& a,const Wrench& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1037:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Wrench&[m[Kâ€™
 1037 | IMETHOD bool Equal([01;36m[Kconst Wrench& a[m[K,const Wrench& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1047:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector2&, const KDL::Vector2&, double)[m[Kâ€™
 1047 | IMETHOD bool [01;36m[KEqual[m[K(const Vector2& a,const Vector2& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1047:35:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector2&[m[Kâ€™
 1047 | IMETHOD bool Equal([01;36m[Kconst Vector2& a[m[K,const Vector2& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:1089:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation2&, const KDL::Rotation2&, double)[m[Kâ€™
 1089 |      inline friend bool [01;36m[KEqual[m[K(const Rotation2& a,const Rotation2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:153:36:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation2&[m[Kâ€™
  153 | inline bool Equal([01;36m[Kconst Rotation2& a[m[K,const Rotation2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:1130:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame2&, const KDL::Frame2&, double)[m[Kâ€™
 1130 |      inline friend bool [01;36m[KEqual[m[K(const Frame2& a,const Frame2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:154:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame2&[m[Kâ€™
  154 | inline bool Equal([01;36m[Kconst Frame2& a[m[K,const Frame2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:557:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation&, const KDL::Rotation&, double)[m[Kâ€™
  557 |     bool [01;36m[KEqual[m[K(const Rotation& a,const Rotation& b,double eps=epsilon);
      |          [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:547:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation&[m[Kâ€™
  547 |      friend bool Equal([01;36m[Kconst Rotation& a[m[K,const Rotation& b,double eps);
      |                        [01;36m[K~~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.inl:1049:46:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KEqual(const double&, const double&, double&)[m[Kâ€™
 1049 |                 Equal(a.data[1],b.data[1],eps[01;31m[K)[m[K   );
      |                                              [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1025:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector&, const KDL::Vector&, double)[m[Kâ€™
 1025 | IMETHOD bool [01;36m[KEqual[m[K(const Vector& a,const Vector& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1025:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
 1025 | IMETHOD bool Equal([01;36m[Kconst Vector& a[m[K,const Vector& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1032:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame&, const KDL::Frame&, double)[m[Kâ€™
 1032 | IMETHOD bool [01;36m[KEqual[m[K(const Frame& a,const Frame& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1032:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame&[m[Kâ€™
 1032 | IMETHOD bool Equal([01;36m[Kconst Frame& a[m[K,const Frame& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1042:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Twist&, const KDL::Twist&, double)[m[Kâ€™
 1042 | IMETHOD bool [01;36m[KEqual[m[K(const Twist& a,const Twist& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1042:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Twist&[m[Kâ€™
 1042 | IMETHOD bool Equal([01;36m[Kconst Twist& a[m[K,const Twist& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1037:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Wrench&, const KDL::Wrench&, double)[m[Kâ€™
 1037 | IMETHOD bool [01;36m[KEqual[m[K(const Wrench& a,const Wrench& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1037:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Wrench&[m[Kâ€™
 1037 | IMETHOD bool Equal([01;36m[Kconst Wrench& a[m[K,const Wrench& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1047:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector2&, const KDL::Vector2&, double)[m[Kâ€™
 1047 | IMETHOD bool [01;36m[KEqual[m[K(const Vector2& a,const Vector2& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1047:35:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector2&[m[Kâ€™
 1047 | IMETHOD bool Equal([01;36m[Kconst Vector2& a[m[K,const Vector2& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:1089:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation2&, const KDL::Rotation2&, double)[m[Kâ€™
 1089 |      inline friend bool [01;36m[KEqual[m[K(const Rotation2& a,const Rotation2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:153:36:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation2&[m[Kâ€™
  153 | inline bool Equal([01;36m[Kconst Rotation2& a[m[K,const Rotation2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:1130:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame2&, const KDL::Frame2&, double)[m[Kâ€™
 1130 |      inline friend bool [01;36m[KEqual[m[K(const Frame2& a,const Frame2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:154:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame2&[m[Kâ€™
  154 | inline bool Equal([01;36m[Kconst Frame2& a[m[K,const Frame2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:557:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation&, const KDL::Rotation&, double)[m[Kâ€™
  557 |     bool [01;36m[KEqual[m[K(const Rotation& a,const Rotation& b,double eps=epsilon);
      |          [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:547:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation&[m[Kâ€™
  547 |      friend bool Equal([01;36m[Kconst Rotation& a[m[K,const Rotation& b,double eps);
      |                        [01;36m[K~~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.inl:[m[K In function â€˜[01m[Kbool KDL::Equal(const KDL::Rotation2&, const KDL::Rotation2&, double)[m[Kâ€™:
[01m[K/usr/include/kdl/frames.inl:1053:31:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KEqual(const double&, const double&, double&)[m[Kâ€™
 1053 |     return ( Equal(a.c,b.c,eps[01;31m[K)[m[K && Equal(a.s,b.s,eps) );
      |                               [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1025:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector&, const KDL::Vector&, double)[m[Kâ€™
 1025 | IMETHOD bool [01;36m[KEqual[m[K(const Vector& a,const Vector& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1025:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
 1025 | IMETHOD bool Equal([01;36m[Kconst Vector& a[m[K,const Vector& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1032:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame&, const KDL::Frame&, double)[m[Kâ€™
 1032 | IMETHOD bool [01;36m[KEqual[m[K(const Frame& a,const Frame& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1032:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame&[m[Kâ€™
 1032 | IMETHOD bool Equal([01;36m[Kconst Frame& a[m[K,const Frame& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1042:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Twist&, const KDL::Twist&, double)[m[Kâ€™
 1042 | IMETHOD bool [01;36m[KEqual[m[K(const Twist& a,const Twist& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1042:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Twist&[m[Kâ€™
 1042 | IMETHOD bool Equal([01;36m[Kconst Twist& a[m[K,const Twist& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1037:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Wrench&, const KDL::Wrench&, double)[m[Kâ€™
 1037 | IMETHOD bool [01;36m[KEqual[m[K(const Wrench& a,const Wrench& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1037:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Wrench&[m[Kâ€™
 1037 | IMETHOD bool Equal([01;36m[Kconst Wrench& a[m[K,const Wrench& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1047:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector2&, const KDL::Vector2&, double)[m[Kâ€™
 1047 | IMETHOD bool [01;36m[KEqual[m[K(const Vector2& a,const Vector2& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1047:35:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector2&[m[Kâ€™
 1047 | IMETHOD bool Equal([01;36m[Kconst Vector2& a[m[K,const Vector2& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1052:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation2&, const KDL::Rotation2&, double)[m[Kâ€™
 1052 | IMETHOD bool [01;36m[KEqual[m[K(const Rotation2& a,const Rotation2& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1052:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation2&[m[Kâ€™
 1052 | IMETHOD bool Equal([01;36m[Kconst Rotation2& a[m[K,const Rotation2& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:1130:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame2&, const KDL::Frame2&, double)[m[Kâ€™
 1130 |      inline friend bool [01;36m[KEqual[m[K(const Frame2& a,const Frame2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:154:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame2&[m[Kâ€™
  154 | inline bool Equal([01;36m[Kconst Frame2& a[m[K,const Frame2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:557:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation&, const KDL::Rotation&, double)[m[Kâ€™
  557 |     bool [01;36m[KEqual[m[K(const Rotation& a,const Rotation& b,double eps=epsilon);
      |          [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:547:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation&[m[Kâ€™
  547 |      friend bool Equal([01;36m[Kconst Rotation& a[m[K,const Rotation& b,double eps);
      |                        [01;36m[K~~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.inl:1053:53:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KEqual(const double&, const double&, double&)[m[Kâ€™
 1053 |     return ( Equal(a.c,b.c,eps) && Equal(a.s,b.s,eps[01;31m[K)[m[K );
      |                                                     [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1025:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector&, const KDL::Vector&, double)[m[Kâ€™
 1025 | IMETHOD bool [01;36m[KEqual[m[K(const Vector& a,const Vector& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1025:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector&[m[Kâ€™
 1025 | IMETHOD bool Equal([01;36m[Kconst Vector& a[m[K,const Vector& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1032:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame&, const KDL::Frame&, double)[m[Kâ€™
 1032 | IMETHOD bool [01;36m[KEqual[m[K(const Frame& a,const Frame& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1032:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame&[m[Kâ€™
 1032 | IMETHOD bool Equal([01;36m[Kconst Frame& a[m[K,const Frame& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1042:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Twist&, const KDL::Twist&, double)[m[Kâ€™
 1042 | IMETHOD bool [01;36m[KEqual[m[K(const Twist& a,const Twist& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1042:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Twist&[m[Kâ€™
 1042 | IMETHOD bool Equal([01;36m[Kconst Twist& a[m[K,const Twist& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1037:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Wrench&, const KDL::Wrench&, double)[m[Kâ€™
 1037 | IMETHOD bool [01;36m[KEqual[m[K(const Wrench& a,const Wrench& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1037:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Wrench&[m[Kâ€™
 1037 | IMETHOD bool Equal([01;36m[Kconst Wrench& a[m[K,const Wrench& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1047:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Vector2&, const KDL::Vector2&, double)[m[Kâ€™
 1047 | IMETHOD bool [01;36m[KEqual[m[K(const Vector2& a,const Vector2& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1047:35:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Vector2&[m[Kâ€™
 1047 | IMETHOD bool Equal([01;36m[Kconst Vector2& a[m[K,const Vector2& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1052:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation2&, const KDL::Rotation2&, double)[m[Kâ€™
 1052 | IMETHOD bool [01;36m[KEqual[m[K(const Rotation2& a,const Rotation2& b,double eps) {
      |              [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1052:37:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation2&[m[Kâ€™
 1052 | IMETHOD bool Equal([01;36m[Kconst Rotation2& a[m[K,const Rotation2& b,double eps) {
      |                    [01;36m[K~~~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.hpp:1130:25:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Frame2&, const KDL::Frame2&, double)[m[Kâ€™
 1130 |      inline friend bool [01;36m[KEqual[m[K(const Frame2& a,const Frame2& b,double eps);
      |                         [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:154:33:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Frame2&[m[Kâ€™
  154 | inline bool Equal([01;36m[Kconst Frame2& a[m[K,const Frame2& b,double eps=epsilon);
      |                   [01;36m[K~~~~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.hpp:557:10:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kbool KDL::Equal(const KDL::Rotation&, const KDL::Rotation&, double)[m[Kâ€™
  557 |     bool [01;36m[KEqual[m[K(const Rotation& a,const Rotation& b,double eps=epsilon);
      |          [01;36m[K^~~~~[m[K
[01m[K/usr/include/kdl/frames.hpp:547:40:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kconst double[m[Kâ€™ to â€˜[01m[Kconst KDL::Rotation&[m[Kâ€™
  547 |      friend bool Equal([01;36m[Kconst Rotation& a[m[K,const Rotation& b,double eps);
      |                        [01;36m[K~~~~~~~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.inl:[m[K In function â€˜[01m[Kvoid KDL::random(KDL::Vector&)[m[Kâ€™:
[01m[K/usr/include/kdl/frames.inl:1208:13:[m[K [01;31m[Kerror: [m[Kinvalid initialization of reference of type â€˜[01m[KKDL::Vector&[m[Kâ€™ from expression of type â€˜[01m[Kdouble[m[Kâ€™
 1208 |  random(a[0][01;31m[K)[m[K;
      |             [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1207:29:[m[K [01;36m[Knote: [m[Kin passing argument 1 of â€˜[01m[Kvoid KDL::random(KDL::Vector&)[m[Kâ€™
 1207 | IMETHOD void random([01;36m[KVector& a[m[K) {
      |                     [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1209:13:[m[K [01;31m[Kerror: [m[Kinvalid initialization of reference of type â€˜[01m[KKDL::Vector&[m[Kâ€™ from expression of type â€˜[01m[Kdouble[m[Kâ€™
 1209 |  random(a[1][01;31m[K)[m[K;
      |             [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1207:29:[m[K [01;36m[Knote: [m[Kin passing argument 1 of â€˜[01m[Kvoid KDL::random(KDL::Vector&)[m[Kâ€™
 1207 | IMETHOD void random([01;36m[KVector& a[m[K) {
      |                     [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1210:13:[m[K [01;31m[Kerror: [m[Kinvalid initialization of reference of type â€˜[01m[KKDL::Vector&[m[Kâ€™ from expression of type â€˜[01m[Kdouble[m[Kâ€™
 1210 |  random(a[2][01;31m[K)[m[K;
      |             [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1207:29:[m[K [01;36m[Knote: [m[Kin passing argument 1 of â€˜[01m[Kvoid KDL::random(KDL::Vector&)[m[Kâ€™
 1207 | IMETHOD void random([01;36m[KVector& a[m[K) {
      |                     [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:[m[K In function â€˜[01m[Kvoid KDL::random(KDL::Rotation&)[m[Kâ€™:
[01m[K/usr/include/kdl/frames.inl:1225:13:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Krandom(double&)[m[Kâ€™
 1225 |  random(alfa[01;31m[K)[m[K;
      |             [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1207:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Vector&)[m[Kâ€™
 1207 | IMETHOD void [01;36m[Krandom[m[K(Vector& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1207:29:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Vector&[m[Kâ€™
 1207 | IMETHOD void random([01;36m[KVector& a[m[K) {
      |                     [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1212:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Twist&)[m[Kâ€™
 1212 | IMETHOD void [01;36m[Krandom[m[K(Twist& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1212:28:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Twist&[m[Kâ€™
 1212 | IMETHOD void random([01;36m[KTwist& a[m[K) {
      |                     [01;36m[K~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1216:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Wrench&)[m[Kâ€™
 1216 | IMETHOD void [01;36m[Krandom[m[K(Wrench& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1216:29:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Wrench&[m[Kâ€™
 1216 | IMETHOD void random([01;36m[KWrench& a[m[K) {
      |                     [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1221:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Rotation&)[m[Kâ€™
 1221 | IMETHOD void [01;36m[Krandom[m[K(Rotation& R) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1221:31:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Rotation&[m[Kâ€™
 1221 | IMETHOD void random([01;36m[KRotation& R[m[K) {
      |                     [01;36m[K~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1226:13:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Krandom(double&)[m[Kâ€™
 1226 |  random(beta[01;31m[K)[m[K;
      |             [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1207:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Vector&)[m[Kâ€™
 1207 | IMETHOD void [01;36m[Krandom[m[K(Vector& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1207:29:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Vector&[m[Kâ€™
 1207 | IMETHOD void random([01;36m[KVector& a[m[K) {
      |                     [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1212:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Twist&)[m[Kâ€™
 1212 | IMETHOD void [01;36m[Krandom[m[K(Twist& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1212:28:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Twist&[m[Kâ€™
 1212 | IMETHOD void random([01;36m[KTwist& a[m[K) {
      |                     [01;36m[K~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1216:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Wrench&)[m[Kâ€™
 1216 | IMETHOD void [01;36m[Krandom[m[K(Wrench& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1216:29:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Wrench&[m[Kâ€™
 1216 | IMETHOD void random([01;36m[KWrench& a[m[K) {
      |                     [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1221:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Rotation&)[m[Kâ€™
 1221 | IMETHOD void [01;36m[Krandom[m[K(Rotation& R) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1221:31:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Rotation&[m[Kâ€™
 1221 | IMETHOD void random([01;36m[KRotation& R[m[K) {
      |                     [01;36m[K~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1227:14:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Krandom(double&)[m[Kâ€™
 1227 |  random(gamma[01;31m[K)[m[K;
      |              [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1207:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Vector&)[m[Kâ€™
 1207 | IMETHOD void [01;36m[Krandom[m[K(Vector& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1207:29:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Vector&[m[Kâ€™
 1207 | IMETHOD void random([01;36m[KVector& a[m[K) {
      |                     [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1212:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Twist&)[m[Kâ€™
 1212 | IMETHOD void [01;36m[Krandom[m[K(Twist& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1212:28:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Twist&[m[Kâ€™
 1212 | IMETHOD void random([01;36m[KTwist& a[m[K) {
      |                     [01;36m[K~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1216:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Wrench&)[m[Kâ€™
 1216 | IMETHOD void [01;36m[Krandom[m[K(Wrench& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1216:29:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Wrench&[m[Kâ€™
 1216 | IMETHOD void random([01;36m[KWrench& a[m[K) {
      |                     [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1221:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Rotation&)[m[Kâ€™
 1221 | IMETHOD void [01;36m[Krandom[m[K(Rotation& R) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1221:31:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Rotation&[m[Kâ€™
 1221 | IMETHOD void random([01;36m[KRotation& R[m[K) {
      |                     [01;36m[K~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:[m[K In function â€˜[01m[Kvoid KDL::posrandom(KDL::Vector&)[m[Kâ€™:
[01m[K/usr/include/kdl/frames.inl:1237:16:[m[K [01;31m[Kerror: [m[Kinvalid initialization of reference of type â€˜[01m[KKDL::Vector&[m[Kâ€™ from expression of type â€˜[01m[Kdouble[m[Kâ€™
 1237 |  posrandom(a[0][01;31m[K)[m[K;
      |                [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1236:32:[m[K [01;36m[Knote: [m[Kin passing argument 1 of â€˜[01m[Kvoid KDL::posrandom(KDL::Vector&)[m[Kâ€™
 1236 | IMETHOD void posrandom([01;36m[KVector& a[m[K) {
      |                        [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1238:16:[m[K [01;31m[Kerror: [m[Kinvalid initialization of reference of type â€˜[01m[KKDL::Vector&[m[Kâ€™ from expression of type â€˜[01m[Kdouble[m[Kâ€™
 1238 |  posrandom(a[1][01;31m[K)[m[K;
      |                [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1236:32:[m[K [01;36m[Knote: [m[Kin passing argument 1 of â€˜[01m[Kvoid KDL::posrandom(KDL::Vector&)[m[Kâ€™
 1236 | IMETHOD void posrandom([01;36m[KVector& a[m[K) {
      |                        [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1239:16:[m[K [01;31m[Kerror: [m[Kinvalid initialization of reference of type â€˜[01m[KKDL::Vector&[m[Kâ€™ from expression of type â€˜[01m[Kdouble[m[Kâ€™
 1239 |  posrandom(a[2][01;31m[K)[m[K;
      |                [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1236:32:[m[K [01;36m[Knote: [m[Kin passing argument 1 of â€˜[01m[Kvoid KDL::posrandom(KDL::Vector&)[m[Kâ€™
 1236 | IMETHOD void posrandom([01;36m[KVector& a[m[K) {
      |                        [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:[m[K In function â€˜[01m[Kvoid KDL::posrandom(KDL::Rotation&)[m[Kâ€™:
[01m[K/usr/include/kdl/frames.inl:1254:16:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Kposrandom(double&)[m[Kâ€™
 1254 |  posrandom(alfa[01;31m[K)[m[K;
      |                [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1236:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Vector&)[m[Kâ€™
 1236 | IMETHOD void [01;36m[Kposrandom[m[K(Vector& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1236:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Vector&[m[Kâ€™
 1236 | IMETHOD void posrandom([01;36m[KVector& a[m[K) {
      |                        [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1241:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Twist&)[m[Kâ€™
 1241 | IMETHOD void [01;36m[Kposrandom[m[K(Twist& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1241:31:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Twist&[m[Kâ€™
 1241 | IMETHOD void posrandom([01;36m[KTwist& a[m[K) {
      |                        [01;36m[K~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1245:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Wrench&)[m[Kâ€™
 1245 | IMETHOD void [01;36m[Kposrandom[m[K(Wrench& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1245:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Wrench&[m[Kâ€™
 1245 | IMETHOD void posrandom([01;36m[KWrench& a[m[K) {
      |                        [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1250:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Rotation&)[m[Kâ€™
 1250 | IMETHOD void [01;36m[Kposrandom[m[K(Rotation& R) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1250:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Rotation&[m[Kâ€™
 1250 | IMETHOD void posrandom([01;36m[KRotation& R[m[K) {
      |                        [01;36m[K~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1255:16:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Kposrandom(double&)[m[Kâ€™
 1255 |  posrandom(beta[01;31m[K)[m[K;
      |                [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1236:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Vector&)[m[Kâ€™
 1236 | IMETHOD void [01;36m[Kposrandom[m[K(Vector& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1236:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Vector&[m[Kâ€™
 1236 | IMETHOD void posrandom([01;36m[KVector& a[m[K) {
      |                        [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1241:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Twist&)[m[Kâ€™
 1241 | IMETHOD void [01;36m[Kposrandom[m[K(Twist& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1241:31:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Twist&[m[Kâ€™
 1241 | IMETHOD void posrandom([01;36m[KTwist& a[m[K) {
      |                        [01;36m[K~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1245:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Wrench&)[m[Kâ€™
 1245 | IMETHOD void [01;36m[Kposrandom[m[K(Wrench& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1245:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Wrench&[m[Kâ€™
 1245 | IMETHOD void posrandom([01;36m[KWrench& a[m[K) {
      |                        [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1250:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Rotation&)[m[Kâ€™
 1250 | IMETHOD void [01;36m[Kposrandom[m[K(Rotation& R) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1250:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Rotation&[m[Kâ€™
 1250 | IMETHOD void posrandom([01;36m[KRotation& R[m[K) {
      |                        [01;36m[K~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1256:17:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Kposrandom(double&)[m[Kâ€™
 1256 |  posrandom(gamma[01;31m[K)[m[K;
      |                 [01;31m[K^[m[K
[01m[K/usr/include/kdl/frames.inl:1236:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Vector&)[m[Kâ€™
 1236 | IMETHOD void [01;36m[Kposrandom[m[K(Vector& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1236:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Vector&[m[Kâ€™
 1236 | IMETHOD void posrandom([01;36m[KVector& a[m[K) {
      |                        [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1241:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Twist&)[m[Kâ€™
 1241 | IMETHOD void [01;36m[Kposrandom[m[K(Twist& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1241:31:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Twist&[m[Kâ€™
 1241 | IMETHOD void posrandom([01;36m[KTwist& a[m[K) {
      |                        [01;36m[K~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1245:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Wrench&)[m[Kâ€™
 1245 | IMETHOD void [01;36m[Kposrandom[m[K(Wrench& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1245:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Wrench&[m[Kâ€™
 1245 | IMETHOD void posrandom([01;36m[KWrench& a[m[K) {
      |                        [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1250:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Rotation&)[m[Kâ€™
 1250 | IMETHOD void [01;36m[Kposrandom[m[K(Rotation& R) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1250:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Rotation&[m[Kâ€™
 1250 | IMETHOD void posrandom([01;36m[KRotation& R[m[K) {
      |                        [01;36m[K~~~~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/jntarray.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver_recursive_newton_euler.hpp:25[m[K,
                 from [01m[K/usr/include/kdl/chaindynparam.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:46[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/jacobian.hpp:[m[K At global scope:
[01m[K/usr/include/kdl/jacobian.hpp:32:63:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   32 |     bool Equal(const Jacobian& a,const Jacobian& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                               [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/jacobian.hpp:32:63:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainidsolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainidsolver_recursive_newton_euler.hpp:25[m[K,
                 from [01m[K/usr/include/kdl/chaindynparam.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:46[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/jntarray.hpp:223:69:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  223 |     bool Equal(const JntArray& src1,const JntArray& src2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                     [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/jntarray.hpp:223:69:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chaindynparam.hpp:27[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:46[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/jntspaceinertiamatrix.hpp:226:95:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  226 | SpaceInertiaMatrix& src1,const JntSpaceInertiaMatrix& src2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                       [01;31m[K^~~~~~~[m[K

[01m[K/usr/include/kdl/jntspaceinertiamatrix.hpp:226:95:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/utilities/rall1d.h:68:42:[m[K [01;31m[Kerror: [m[Kexpected nested-name-specifier before â€˜[01m[KTI[m[Kâ€™
   68 |         explicit INLINE  Rall1d(typename [01;31m[KTI[m[K<T>::Arg c)
      |                                          [01;31m[K^~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:68:44:[m[K [01;31m[Kerror: [m[Kexpected â€˜[01m[K,[m[Kâ€™ or â€˜[01m[K...[m[Kâ€™ before â€˜[01m[K<[m[Kâ€™ token
   68 |         explicit INLINE  Rall1d(typename TI[01;31m[K<[m[KT>::Arg c)
      |                                            [01;31m[K^[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:71:32:[m[K [01;31m[Kerror: [m[Kexpected nested-name-specifier before â€˜[01m[KTI[m[Kâ€™
   71 |         INLINE Rall1d(typename [01;31m[KTI[m[K<T>::Arg tn, typename TI<V>::Arg afg):t(tn),grad(afg) {}
      |                                [01;31m[K^~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:71:34:[m[K [01;31m[Kerror: [m[Kexpected â€˜[01m[K,[m[Kâ€™ or â€˜[01m[K...[m[Kâ€™ before â€˜[01m[K<[m[Kâ€™ token
   71 |         INLINE Rall1d(typename TI[01;31m[K<[m[KT>::Arg tn, typename TI<V>::Arg afg):t(tn),grad(afg) {}
      |                                  [01;31m[K^[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:71:16:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(int)[m[Kâ€™ cannot be overloaded with â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(int)[m[Kâ€™
   71 |         INLINE [01;31m[KRall1d[m[K(typename TI<T>::Arg tn, typename TI<V>::Arg afg):t(tn),grad(afg) {}
      |                [01;31m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:68:26:[m[K [01;36m[Knote: [m[Kprevious declaration â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(int)[m[Kâ€™
   68 |         explicit INLINE  [01;36m[KRall1d[m[K(typename TI<T>::Arg c)
      |                          [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:[m[K In constructor â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(int)[m[Kâ€™:
[01m[K/usr/include/kdl/utilities/rall1d.h:69:18:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kc[m[Kâ€™ was not declared in this scope
   69 |             {t=T([01;31m[Kc[m[K);SetToZero(grad);}
      |                  [01;31m[K^[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:[m[K In constructor â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(int)[m[Kâ€™:
[01m[K/usr/include/kdl/utilities/rall1d.h:71:74:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Ktn[m[Kâ€™ was not declared in this scope; did you mean â€˜[01m[Kt[m[Kâ€™?
   71 | LINE Rall1d(typename TI<T>::Arg tn, typename TI<V>::Arg afg):t([01;31m[Ktn[m[K),grad(afg) {}
      |                                                                [01;31m[K^~[m[K
      |                                                                [32m[Kt[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:71:83:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kafg[m[Kâ€™ was not declared in this scope
   71 | (typename TI<T>::Arg tn, typename TI<V>::Arg afg):t(tn),grad([01;31m[Kafg[m[K) {}
      |                                                              [01;31m[K^~~[m[K

[01m[K/usr/include/kdl/utilities/rall1d.h:[m[K At global scope:
[01m[K/usr/include/kdl/utilities/rall1d.h:469:77:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  469 | E  bool Equal(const Rall1d<T,V,S>& y,const Rall1d<T,V,S>& x,double eps=[01;31m[Kepsilon[m[K)
      |                                                                        [01;31m[K^~~~~~~[m[K

[01m[K/usr/include/kdl/utilities/rall1d.h:469:77:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:[m[K In function â€˜[01m[KKDL::doubleVel KDL::diff(const doubleVel&, const doubleVel&, double)[m[Kâ€™:
[01m[K/usr/include/kdl/framevel.hpp:39:50:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KKDL::Rall1d<double>::Rall1d(double, double)[m[Kâ€™
   39 |  return doubleVel((b.t-a.t)/dt,(b.grad-a.grad)/dt[01;31m[K)[m[K;
      |                                                  [01;31m[K^[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/utilities/rall1d.h:73:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(const KDL::Rall1d<T, V, S>&) [with T = double; V = double; S = double][m[Kâ€™
   73 |         INLINE [01;36m[KRall1d[m[K(const Rall1d<T,V,S>& r):t(r.t),grad(r.grad) {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:73:16:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 2 provided
[01m[K/usr/include/kdl/utilities/rall1d.h:68:26:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(int) [with T = double; V = double; S = double][m[Kâ€™
   68 |         explicit INLINE  [01;36m[KRall1d[m[K(typename TI<T>::Arg c)
      |                          [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:68:26:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 2 provided
[01m[K/usr/include/kdl/utilities/rall1d.h:59:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d() [with T = double; V = double; S = double][m[Kâ€™
   59 |         INLINE [01;36m[KRall1d[m[K() {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:59:16:[m[K [01;36m[Knote: [m[K  candidate expects 0 arguments, 2 provided
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:[m[K In function â€˜[01m[KKDL::doubleVel KDL::addDelta(const doubleVel&, const doubleVel&, double)[m[Kâ€™:
[01m[K/usr/include/kdl/framevel.hpp:43:48:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KKDL::Rall1d<double>::Rall1d(double, double)[m[Kâ€™
   43 |  return doubleVel(a.t+da.t*dt,a.grad+da.grad*dt[01;31m[K)[m[K;
      |                                                [01;31m[K^[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/utilities/rall1d.h:73:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(const KDL::Rall1d<T, V, S>&) [with T = double; V = double; S = double][m[Kâ€™
   73 |         INLINE [01;36m[KRall1d[m[K(const Rall1d<T,V,S>& r):t(r.t),grad(r.grad) {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:73:16:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 2 provided
[01m[K/usr/include/kdl/utilities/rall1d.h:68:26:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(int) [with T = double; V = double; S = double][m[Kâ€™
   68 |         explicit INLINE  [01;36m[KRall1d[m[K(typename TI<T>::Arg c)
      |                          [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:68:26:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 2 provided
[01m[K/usr/include/kdl/utilities/rall1d.h:59:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d() [with T = double; V = double; S = double][m[Kâ€™
   59 |         INLINE [01;36m[KRall1d[m[K() {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:59:16:[m[K [01;36m[Knote: [m[K  candidate expects 0 arguments, 2 provided
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:[m[K In function â€˜[01m[Kvoid KDL::random(KDL::doubleVel&)[m[Kâ€™:
[01m[K/usr/include/kdl/framevel.hpp:47:12:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Krandom(double&)[m[Kâ€™
   47 |  random(F.t[01;31m[K)[m[K;
      |            [01;31m[K^[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.inl:1207:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Vector&)[m[Kâ€™
 1207 | IMETHOD void [01;36m[Krandom[m[K(Vector& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1207:29:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Vector&[m[Kâ€™
 1207 | IMETHOD void random([01;36m[KVector& a[m[K) {
      |                     [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1212:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Twist&)[m[Kâ€™
 1212 | IMETHOD void [01;36m[Krandom[m[K(Twist& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1212:28:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Twist&[m[Kâ€™
 1212 | IMETHOD void random([01;36m[KTwist& a[m[K) {
      |                     [01;36m[K~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1216:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Wrench&)[m[Kâ€™
 1216 | IMETHOD void [01;36m[Krandom[m[K(Wrench& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1216:29:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Wrench&[m[Kâ€™
 1216 | IMETHOD void random([01;36m[KWrench& a[m[K) {
      |                     [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1221:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Rotation&)[m[Kâ€™
 1221 | IMETHOD void [01;36m[Krandom[m[K(Rotation& R) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1221:31:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Rotation&[m[Kâ€™
 1221 | IMETHOD void random([01;36m[KRotation& R[m[K) {
      |                     [01;36m[K~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1231:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Frame&)[m[Kâ€™
 1231 | IMETHOD void [01;36m[Krandom[m[K(Frame& F) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1231:28:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Frame&[m[Kâ€™
 1231 | IMETHOD void random([01;36m[KFrame& F[m[K) {
      |                     [01;36m[K~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:46:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::doubleVel&)[m[Kâ€™
   46 | IMETHOD void [01;36m[Krandom[m[K(doubleVel& F) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/framevel.hpp:46:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::doubleVel&[m[Kâ€™ {aka â€˜[01m[KKDL::Rall1d<double>&[m[Kâ€™}
   46 | IMETHOD void random([01;36m[KdoubleVel& F[m[K) {
      |                     [01;36m[K~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/framevel.hpp:48:15:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Krandom(double&)[m[Kâ€™
   48 |  random(F.grad[01;31m[K)[m[K;
      |               [01;31m[K^[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.inl:1207:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Vector&)[m[Kâ€™
 1207 | IMETHOD void [01;36m[Krandom[m[K(Vector& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1207:29:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Vector&[m[Kâ€™
 1207 | IMETHOD void random([01;36m[KVector& a[m[K) {
      |                     [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1212:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Twist&)[m[Kâ€™
 1212 | IMETHOD void [01;36m[Krandom[m[K(Twist& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1212:28:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Twist&[m[Kâ€™
 1212 | IMETHOD void random([01;36m[KTwist& a[m[K) {
      |                     [01;36m[K~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1216:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Wrench&)[m[Kâ€™
 1216 | IMETHOD void [01;36m[Krandom[m[K(Wrench& a) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1216:29:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Wrench&[m[Kâ€™
 1216 | IMETHOD void random([01;36m[KWrench& a[m[K) {
      |                     [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1221:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Rotation&)[m[Kâ€™
 1221 | IMETHOD void [01;36m[Krandom[m[K(Rotation& R) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1221:31:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Rotation&[m[Kâ€™
 1221 | IMETHOD void random([01;36m[KRotation& R[m[K) {
      |                     [01;36m[K~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1231:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::Frame&)[m[Kâ€™
 1231 | IMETHOD void [01;36m[Krandom[m[K(Frame& F) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1231:28:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Frame&[m[Kâ€™
 1231 | IMETHOD void random([01;36m[KFrame& F[m[K) {
      |                     [01;36m[K~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:46:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::random(KDL::doubleVel&)[m[Kâ€™
   46 | IMETHOD void [01;36m[Krandom[m[K(doubleVel& F) {
      |              [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/framevel.hpp:46:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::doubleVel&[m[Kâ€™ {aka â€˜[01m[KKDL::Rall1d<double>&[m[Kâ€™}
   46 | IMETHOD void random([01;36m[KdoubleVel& F[m[K) {
      |                     [01;36m[K~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/framevel.hpp:[m[K In function â€˜[01m[Kvoid KDL::posrandom(KDL::doubleVel&)[m[Kâ€™:
[01m[K/usr/include/kdl/framevel.hpp:51:15:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Kposrandom(double&)[m[Kâ€™
   51 |  posrandom(F.t[01;31m[K)[m[K;
      |               [01;31m[K^[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.inl:1236:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Vector&)[m[Kâ€™
 1236 | IMETHOD void [01;36m[Kposrandom[m[K(Vector& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1236:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Vector&[m[Kâ€™
 1236 | IMETHOD void posrandom([01;36m[KVector& a[m[K) {
      |                        [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1241:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Twist&)[m[Kâ€™
 1241 | IMETHOD void [01;36m[Kposrandom[m[K(Twist& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1241:31:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Twist&[m[Kâ€™
 1241 | IMETHOD void posrandom([01;36m[KTwist& a[m[K) {
      |                        [01;36m[K~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1245:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Wrench&)[m[Kâ€™
 1245 | IMETHOD void [01;36m[Kposrandom[m[K(Wrench& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1245:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Wrench&[m[Kâ€™
 1245 | IMETHOD void posrandom([01;36m[KWrench& a[m[K) {
      |                        [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1250:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Rotation&)[m[Kâ€™
 1250 | IMETHOD void [01;36m[Kposrandom[m[K(Rotation& R) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1250:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Rotation&[m[Kâ€™
 1250 | IMETHOD void posrandom([01;36m[KRotation& R[m[K) {
      |                        [01;36m[K~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1260:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Frame&)[m[Kâ€™
 1260 | IMETHOD void [01;36m[Kposrandom[m[K(Frame& F) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1260:31:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Frame&[m[Kâ€™
 1260 | IMETHOD void posrandom([01;36m[KFrame& F[m[K) {
      |                        [01;36m[K~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:50:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::doubleVel&)[m[Kâ€™
   50 | IMETHOD void [01;36m[Kposrandom[m[K(doubleVel& F) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.hpp:50:35:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::doubleVel&[m[Kâ€™ {aka â€˜[01m[KKDL::Rall1d<double>&[m[Kâ€™}
   50 | IMETHOD void posrandom([01;36m[KdoubleVel& F[m[K) {
      |                        [01;36m[K~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/framevel.hpp:52:18:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[Kposrandom(double&)[m[Kâ€™
   52 |  posrandom(F.grad[01;31m[K)[m[K;
      |                  [01;31m[K^[m[K
In file included from [01m[K/usr/include/kdl/frames.hpp:1261[m[K,
                 from [01m[K/usr/include/kdl/segment.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chain.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:44[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frames.inl:1236:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Vector&)[m[Kâ€™
 1236 | IMETHOD void [01;36m[Kposrandom[m[K(Vector& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1236:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Vector&[m[Kâ€™
 1236 | IMETHOD void posrandom([01;36m[KVector& a[m[K) {
      |                        [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1241:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Twist&)[m[Kâ€™
 1241 | IMETHOD void [01;36m[Kposrandom[m[K(Twist& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1241:31:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Twist&[m[Kâ€™
 1241 | IMETHOD void posrandom([01;36m[KTwist& a[m[K) {
      |                        [01;36m[K~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1245:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Wrench&)[m[Kâ€™
 1245 | IMETHOD void [01;36m[Kposrandom[m[K(Wrench& a) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1245:32:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Wrench&[m[Kâ€™
 1245 | IMETHOD void posrandom([01;36m[KWrench& a[m[K) {
      |                        [01;36m[K~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1250:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Rotation&)[m[Kâ€™
 1250 | IMETHOD void [01;36m[Kposrandom[m[K(Rotation& R) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1250:34:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Rotation&[m[Kâ€™
 1250 | IMETHOD void posrandom([01;36m[KRotation& R[m[K) {
      |                        [01;36m[K~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/frames.inl:1260:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::Frame&)[m[Kâ€™
 1260 | IMETHOD void [01;36m[Kposrandom[m[K(Frame& F) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/frames.inl:1260:31:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::Frame&[m[Kâ€™
 1260 | IMETHOD void posrandom([01;36m[KFrame& F[m[K) {
      |                        [01;36m[K~~~~~~~^[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:50:14:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[Kvoid KDL::posrandom(KDL::doubleVel&)[m[Kâ€™
   50 | IMETHOD void [01;36m[Kposrandom[m[K(doubleVel& F) {
      |              [01;36m[K^~~~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.hpp:50:35:[m[K [01;36m[Knote: [m[K  no known conversion for argument 1 from â€˜[01m[Kdouble[m[Kâ€™ to â€˜[01m[KKDL::doubleVel&[m[Kâ€™ {aka â€˜[01m[KKDL::Rall1d<double>&[m[Kâ€™}
   50 | IMETHOD void posrandom([01;36m[KdoubleVel& F[m[K) {
      |                        [01;36m[K~~~~~~~~~~~^[m[K
[01m[K/usr/include/kdl/framevel.hpp:[m[K At global scope:
[01m[K/usr/include/kdl/framevel.hpp:71:71:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   71 | IMETHOD bool Equal(const VectorVel& r1,const VectorVel& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                       [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.hpp:71:71:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:72:68:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   72 | IMETHOD bool Equal(const Vector& r1,const VectorVel& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                    [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.hpp:72:68:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:73:68:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   73 | IMETHOD bool Equal(const VectorVel& r1,const Vector& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                    [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.hpp:73:68:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:74:75:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   74 | HOD bool Equal(const RotationVel& r1,const RotationVel& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                       [01;31m[K^~~~~~~[m[K

[01m[K/usr/include/kdl/framevel.hpp:74:75:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:75:72:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   75 | METHOD bool Equal(const Rotation& r1,const RotationVel& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                       [01;31m[K^~~~~~~[m[K

[01m[K/usr/include/kdl/framevel.hpp:75:72:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:76:72:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   76 | METHOD bool Equal(const RotationVel& r1,const Rotation& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                       [01;31m[K^~~~~~~[m[K

[01m[K/usr/include/kdl/framevel.hpp:76:72:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:77:69:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   77 | IMETHOD bool Equal(const FrameVel& r1,const FrameVel& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                     [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.hpp:77:69:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:78:66:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   78 | IMETHOD bool Equal(const Frame& r1,const FrameVel& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                  [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.hpp:78:66:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:79:66:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   79 | IMETHOD bool Equal(const FrameVel& r1,const Frame& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                  [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.hpp:79:66:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:80:67:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   80 | IMETHOD bool Equal(const TwistVel& a,const TwistVel& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                                   [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.hpp:80:67:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:81:64:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   81 | IMETHOD bool Equal(const Twist& a,const TwistVel& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                                [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.hpp:81:64:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.hpp:82:64:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   82 | IMETHOD bool Equal(const TwistVel& a,const Twist& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                                [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/framevel.hpp:82:64:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:387[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.inl:[m[K In member function â€˜[01m[KKDL::doubleVel KDL::VectorVel::Norm() const[m[Kâ€™:
[01m[K/usr/include/kdl/framevel.inl:320:34:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KKDL::Rall1d<double>::Rall1d(double&, double)[m[Kâ€™
  320 |     return doubleVel(n,dot(p,v)/n[01;31m[K)[m[K;
      |                                  [01;31m[K^[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/utilities/rall1d.h:73:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(const KDL::Rall1d<T, V, S>&) [with T = double; V = double; S = double][m[Kâ€™
   73 |         INLINE [01;36m[KRall1d[m[K(const Rall1d<T,V,S>& r):t(r.t),grad(r.grad) {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:73:16:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 2 provided
[01m[K/usr/include/kdl/utilities/rall1d.h:68:26:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(int) [with T = double; V = double; S = double][m[Kâ€™
   68 |         explicit INLINE  [01;36m[KRall1d[m[K(typename TI<T>::Arg c)
      |                          [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:68:26:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 2 provided
[01m[K/usr/include/kdl/utilities/rall1d.h:59:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d() [with T = double; V = double; S = double][m[Kâ€™
   59 |         INLINE [01;36m[KRall1d[m[K() {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:59:16:[m[K [01;36m[Knote: [m[K  candidate expects 0 arguments, 2 provided
In file included from [01m[K/usr/include/kdl/framevel.hpp:387[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.inl:[m[K In function â€˜[01m[KKDL::doubleVel KDL::dot(const KDL::VectorVel&, const KDL::VectorVel&)[m[Kâ€™:
[01m[K/usr/include/kdl/framevel.inl:358:72:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KKDL::Rall1d<double>::Rall1d(double, double)[m[Kâ€™
  358 |     return doubleVel(dot(lhs.p,rhs.p),dot(lhs.p,rhs.v)+dot(lhs.v,rhs.p)[01;31m[K)[m[K;
      |                                                                        [01;31m[K^[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/utilities/rall1d.h:73:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(const KDL::Rall1d<T, V, S>&) [with T = double; V = double; S = double][m[Kâ€™
   73 |         INLINE [01;36m[KRall1d[m[K(const Rall1d<T,V,S>& r):t(r.t),grad(r.grad) {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:73:16:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 2 provided
[01m[K/usr/include/kdl/utilities/rall1d.h:68:26:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(int) [with T = double; V = double; S = double][m[Kâ€™
   68 |         explicit INLINE  [01;36m[KRall1d[m[K(typename TI<T>::Arg c)
      |                          [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:68:26:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 2 provided
[01m[K/usr/include/kdl/utilities/rall1d.h:59:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d() [with T = double; V = double; S = double][m[Kâ€™
   59 |         INLINE [01;36m[KRall1d[m[K() {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:59:16:[m[K [01;36m[Knote: [m[K  candidate expects 0 arguments, 2 provided
In file included from [01m[K/usr/include/kdl/framevel.hpp:387[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.inl:[m[K In function â€˜[01m[KKDL::doubleVel KDL::dot(const KDL::VectorVel&, const KDL::Vector&)[m[Kâ€™:
[01m[K/usr/include/kdl/framevel.inl:361:51:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KKDL::Rall1d<double>::Rall1d(double, double)[m[Kâ€™
  361 |     return doubleVel(dot(lhs.p,rhs),dot(lhs.v,rhs)[01;31m[K)[m[K;
      |                                                   [01;31m[K^[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/utilities/rall1d.h:73:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(const KDL::Rall1d<T, V, S>&) [with T = double; V = double; S = double][m[Kâ€™
   73 |         INLINE [01;36m[KRall1d[m[K(const Rall1d<T,V,S>& r):t(r.t),grad(r.grad) {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:73:16:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 2 provided
[01m[K/usr/include/kdl/utilities/rall1d.h:68:26:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(int) [with T = double; V = double; S = double][m[Kâ€™
   68 |         explicit INLINE  [01;36m[KRall1d[m[K(typename TI<T>::Arg c)
      |                          [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:68:26:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 2 provided
[01m[K/usr/include/kdl/utilities/rall1d.h:59:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d() [with T = double; V = double; S = double][m[Kâ€™
   59 |         INLINE [01;36m[KRall1d[m[K() {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:59:16:[m[K [01;36m[Knote: [m[K  candidate expects 0 arguments, 2 provided
In file included from [01m[K/usr/include/kdl/framevel.hpp:387[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/framevel.inl:[m[K In function â€˜[01m[KKDL::doubleVel KDL::dot(const KDL::Vector&, const KDL::VectorVel&)[m[Kâ€™:
[01m[K/usr/include/kdl/framevel.inl:364:51:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KKDL::Rall1d<double>::Rall1d(double, double)[m[Kâ€™
  364 |     return doubleVel(dot(lhs,rhs.p),dot(lhs,rhs.v)[01;31m[K)[m[K;
      |                                                   [01;31m[K^[m[K
In file included from [01m[K/usr/include/kdl/framevel.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:26[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/utilities/rall1d.h:73:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(const KDL::Rall1d<T, V, S>&) [with T = double; V = double; S = double][m[Kâ€™
   73 |         INLINE [01;36m[KRall1d[m[K(const Rall1d<T,V,S>& r):t(r.t),grad(r.grad) {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:73:16:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 2 provided
[01m[K/usr/include/kdl/utilities/rall1d.h:68:26:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d(int) [with T = double; V = double; S = double][m[Kâ€™
   68 |         explicit INLINE  [01;36m[KRall1d[m[K(typename TI<T>::Arg c)
      |                          [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:68:26:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 2 provided
[01m[K/usr/include/kdl/utilities/rall1d.h:59:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall1d<T, V, S>::Rall1d() [with T = double; V = double; S = double][m[Kâ€™
   59 |         INLINE [01;36m[KRall1d[m[K() {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall1d.h:59:16:[m[K [01;36m[Knote: [m[K  candidate expects 0 arguments, 2 provided
In file included from [01m[K/usr/include/kdl/frameacc.hpp:33[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/utilities/rall2d.h:[m[K At global scope:
[01m[K/usr/include/kdl/utilities/rall2d.h:64:42:[m[K [01;31m[Kerror: [m[Kexpected nested-name-specifier before â€˜[01m[KTI[m[Kâ€™
   64 |         explicit INLINE  Rall2d(typename [01;31m[KTI[m[K<T>::Arg c)
      |                                          [01;31m[K^~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:64:44:[m[K [01;31m[Kerror: [m[Kexpected â€˜[01m[K,[m[Kâ€™ or â€˜[01m[K...[m[Kâ€™ before â€˜[01m[K<[m[Kâ€™ token
   64 |         explicit INLINE  Rall2d(typename TI[01;31m[K<[m[KT>::Arg c)
      |                                            [01;31m[K^[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:67:32:[m[K [01;31m[Kerror: [m[Kexpected nested-name-specifier before â€˜[01m[KTI[m[Kâ€™
   67 |         INLINE Rall2d(typename [01;31m[KTI[m[K<T>::Arg tn,const V& afg):t(tn),d(afg) {SetToZero(dd);}
      |                                [01;31m[K^~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:67:34:[m[K [01;31m[Kerror: [m[Kexpected â€˜[01m[K,[m[Kâ€™ or â€˜[01m[K...[m[Kâ€™ before â€˜[01m[K<[m[Kâ€™ token
   67 |         INLINE Rall2d(typename TI[01;31m[K<[m[KT>::Arg tn,const V& afg):t(tn),d(afg) {SetToZero(dd);}
      |                                  [01;31m[K^[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:67:16:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(int)[m[Kâ€™ cannot be overloaded with â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(int)[m[Kâ€™
   67 |         INLINE [01;31m[KRall2d[m[K(typename TI<T>::Arg tn,const V& afg):t(tn),d(afg) {SetToZero(dd);}
      |                [01;31m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:64:26:[m[K [01;36m[Knote: [m[Kprevious declaration â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(int)[m[Kâ€™
   64 |         explicit INLINE  [01;36m[KRall2d[m[K(typename TI<T>::Arg c)
      |                          [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:69:32:[m[K [01;31m[Kerror: [m[Kexpected nested-name-specifier before â€˜[01m[KTI[m[Kâ€™
   69 |         INLINE Rall2d(typename [01;31m[KTI[m[K<T>::Arg tn,const V& afg,const V& afg2):t(tn),d(afg),dd(afg2) {}
      |                                [01;31m[K^~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:69:34:[m[K [01;31m[Kerror: [m[Kexpected â€˜[01m[K,[m[Kâ€™ or â€˜[01m[K...[m[Kâ€™ before â€˜[01m[K<[m[Kâ€™ token
   69 |         INLINE Rall2d(typename TI[01;31m[K<[m[KT>::Arg tn,const V& afg,const V& afg2):t(tn),d(afg),dd(afg2) {}
      |                                  [01;31m[K^[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:69:16:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(int)[m[Kâ€™ cannot be overloaded with â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(int)[m[Kâ€™
   69 |         INLINE [01;31m[KRall2d[m[K(typename TI<T>::Arg tn,const V& afg,const V& afg2):t(tn),d(afg),dd(afg2) {}
      |                [01;31m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:64:26:[m[K [01;36m[Knote: [m[Kprevious declaration â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(int)[m[Kâ€™
   64 |         explicit INLINE  [01;36m[KRall2d[m[K(typename TI<T>::Arg c)
      |                          [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:[m[K In constructor â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(int)[m[Kâ€™:
[01m[K/usr/include/kdl/utilities/rall2d.h:65:16:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kc[m[Kâ€™ was not declared in this scope
   65 |             {t=[01;31m[Kc[m[K;SetToZero(d);SetToZero(dd);}
      |                [01;31m[K^[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:[m[K In constructor â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(int)[m[Kâ€™:
[01m[K/usr/include/kdl/utilities/rall2d.h:67:62:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Ktn[m[Kâ€™ was not declared in this scope; did you mean â€˜[01m[Kt[m[Kâ€™?
   67 |         INLINE Rall2d(typename TI<T>::Arg tn,const V& afg):t([01;31m[Ktn[m[K),d(afg) {SetToZero(dd);}
      |                                                              [01;31m[K^~[m[K
      |                                                              [32m[Kt[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:67:68:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kafg[m[Kâ€™ was not declared in this scope
   67 |   INLINE Rall2d(typename TI<T>::Arg tn,const V& afg):t(tn),d([01;31m[Kafg[m[K) {SetToZero(dd);}
      |                                                              [01;31m[K^~~[m[K

[01m[K/usr/include/kdl/utilities/rall2d.h:[m[K In constructor â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(int)[m[Kâ€™:
[01m[K/usr/include/kdl/utilities/rall2d.h:69:76:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Ktn[m[Kâ€™ was not declared in this scope; did you mean â€˜[01m[Kt[m[Kâ€™?
   69 |  Rall2d(typename TI<T>::Arg tn,const V& afg,const V& afg2):t([01;31m[Ktn[m[K),d(afg),dd(afg2) {}
      |                                                              [01;31m[K^~[m[K
      |                                                              [32m[Kt[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:69:82:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kafg[m[Kâ€™ was not declared in this scope
   69 | l2d(typename TI<T>::Arg tn,const V& afg,const V& afg2):t(tn),d([01;31m[Kafg[m[K),dd(afg2) {}
      |                                                                [01;31m[K^~~[m[K

[01m[K/usr/include/kdl/utilities/rall2d.h:69:90:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kafg2[m[Kâ€™ was not declared in this scope
   69 | l2d(typename TI<T>::Arg tn,const V& afg,const V& afg2):t(tn),d(afg),dd([01;31m[Kafg2[m[K) {}
      |                                                                        [01;31m[K^~~~[m[K

[01m[K/usr/include/kdl/utilities/rall2d.h:[m[K At global scope:
[01m[K/usr/include/kdl/utilities/rall2d.h:526:77:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
  526 | E  bool Equal(const Rall2d<T,V,S>& y,const Rall2d<T,V,S>& x,double eps=[01;31m[Kepsilon[m[K)
      |                                                                        [01;31m[K^~~~~~~[m[K

[01m[K/usr/include/kdl/utilities/rall2d.h:526:77:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.hpp:48:69:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   48 | IMETHOD bool Equal(const FrameAcc& r1,const FrameAcc& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                     [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.hpp:48:69:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.hpp:49:66:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   49 | IMETHOD bool Equal(const Frame& r1,const FrameAcc& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                  [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.hpp:49:66:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.hpp:50:66:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   50 | IMETHOD bool Equal(const FrameAcc& r1,const Frame& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                  [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.hpp:50:66:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.hpp:51:75:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   51 | HOD bool Equal(const RotationAcc& r1,const RotationAcc& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                       [01;31m[K^~~~~~~[m[K

[01m[K/usr/include/kdl/frameacc.hpp:51:75:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.hpp:52:72:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   52 | METHOD bool Equal(const Rotation& r1,const RotationAcc& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                       [01;31m[K^~~~~~~[m[K

[01m[K/usr/include/kdl/frameacc.hpp:52:72:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.hpp:53:72:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   53 | METHOD bool Equal(const RotationAcc& r1,const Rotation& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                       [01;31m[K^~~~~~~[m[K

[01m[K/usr/include/kdl/frameacc.hpp:53:72:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.hpp:54:67:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   54 | IMETHOD bool Equal(const TwistAcc& a,const TwistAcc& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                                   [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.hpp:54:67:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.hpp:55:64:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   55 | IMETHOD bool Equal(const Twist& a,const TwistAcc& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                                [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.hpp:55:64:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.hpp:56:64:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   56 | IMETHOD bool Equal(const TwistAcc& a,const Twist& b,double eps=[01;31m[Kepsilon[m[K);
      |                                                                [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.hpp:56:64:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.hpp:57:71:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   57 | IMETHOD bool Equal(const VectorAcc& r1,const VectorAcc& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                       [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.hpp:57:71:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.hpp:58:68:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   58 | IMETHOD bool Equal(const Vector& r1,const VectorAcc& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                    [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.hpp:58:68:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.hpp:59:68:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   59 | IMETHOD bool Equal(const VectorAcc& r1,const Vector& r2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                    [01;31m[K^~~~~~~[m[K
[01m[K/usr/include/kdl/frameacc.hpp:59:68:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/frameacc.hpp:267[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.inl:[m[K In function â€˜[01m[KKDL::doubleAcc KDL::dot(const KDL::VectorAcc&, const KDL::VectorAcc&)[m[Kâ€™:
[01m[K/usr/include/kdl/frameacc.inl:141:21:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KKDL::Rall2d<double, double, double>::Rall2d(double, double, double)[m[Kâ€™
  141 |                     [01;31m[K)[m[K;
      |                     [01;31m[K^[m[K
In file included from [01m[K/usr/include/kdl/frameacc.hpp:33[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/utilities/rall2d.h:72:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(const KDL::Rall2d<T, V, S>&) [with T = double; V = double; S = double][m[Kâ€™
   72 |         INLINE [01;36m[KRall2d[m[K(const Rall2d<T,V,S>& r):t(r.t),d(r.d),dd(r.dd) {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:72:16:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 3 provided
[01m[K/usr/include/kdl/utilities/rall2d.h:64:26:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(int) [with T = double; V = double; S = double][m[Kâ€™
   64 |         explicit INLINE  [01;36m[KRall2d[m[K(typename TI<T>::Arg c)
      |                          [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:64:26:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 3 provided
[01m[K/usr/include/kdl/utilities/rall2d.h:62:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d() [with T = double; V = double; S = double][m[Kâ€™
   62 |         INLINE [01;36m[KRall2d[m[K() {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:62:16:[m[K [01;36m[Knote: [m[K  candidate expects 0 arguments, 3 provided
In file included from [01m[K/usr/include/kdl/frameacc.hpp:267[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.inl:[m[K In function â€˜[01m[KKDL::doubleAcc KDL::dot(const KDL::VectorAcc&, const KDL::Vector&)[m[Kâ€™:
[01m[K/usr/include/kdl/frameacc.inl:148:21:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KKDL::Rall2d<double, double, double>::Rall2d(double, double, double)[m[Kâ€™
  148 |                     [01;31m[K)[m[K;
      |                     [01;31m[K^[m[K
In file included from [01m[K/usr/include/kdl/frameacc.hpp:33[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/utilities/rall2d.h:72:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(const KDL::Rall2d<T, V, S>&) [with T = double; V = double; S = double][m[Kâ€™
   72 |         INLINE [01;36m[KRall2d[m[K(const Rall2d<T,V,S>& r):t(r.t),d(r.d),dd(r.dd) {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:72:16:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 3 provided
[01m[K/usr/include/kdl/utilities/rall2d.h:64:26:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(int) [with T = double; V = double; S = double][m[Kâ€™
   64 |         explicit INLINE  [01;36m[KRall2d[m[K(typename TI<T>::Arg c)
      |                          [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:64:26:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 3 provided
[01m[K/usr/include/kdl/utilities/rall2d.h:62:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d() [with T = double; V = double; S = double][m[Kâ€™
   62 |         INLINE [01;36m[KRall2d[m[K() {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:62:16:[m[K [01;36m[Knote: [m[K  candidate expects 0 arguments, 3 provided
In file included from [01m[K/usr/include/kdl/frameacc.hpp:267[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/frameacc.inl:[m[K In function â€˜[01m[KKDL::doubleAcc KDL::dot(const KDL::Vector&, const KDL::VectorAcc&)[m[Kâ€™:
[01m[K/usr/include/kdl/frameacc.inl:155:21:[m[K [01;31m[Kerror: [m[Kno matching function for call to â€˜[01m[KKDL::Rall2d<double, double, double>::Rall2d(double, double, double)[m[Kâ€™
  155 |                     [01;31m[K)[m[K;
      |                     [01;31m[K^[m[K
In file included from [01m[K/usr/include/kdl/frameacc.hpp:33[m[K,
                 from [01m[K/usr/include/kdl/chainfksolver.hpp:27[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/utilities/rall2d.h:72:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(const KDL::Rall2d<T, V, S>&) [with T = double; V = double; S = double][m[Kâ€™
   72 |         INLINE [01;36m[KRall2d[m[K(const Rall2d<T,V,S>& r):t(r.t),d(r.d),dd(r.dd) {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:72:16:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 3 provided
[01m[K/usr/include/kdl/utilities/rall2d.h:64:26:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d(int) [with T = double; V = double; S = double][m[Kâ€™
   64 |         explicit INLINE  [01;36m[KRall2d[m[K(typename TI<T>::Arg c)
      |                          [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:64:26:[m[K [01;36m[Knote: [m[K  candidate expects 1 argument, 3 provided
[01m[K/usr/include/kdl/utilities/rall2d.h:62:16:[m[K [01;36m[Knote: [m[Kcandidate: â€˜[01m[KKDL::Rall2d<T, V, S>::Rall2d() [with T = double; V = double; S = double][m[Kâ€™
   62 |         INLINE [01;36m[KRall2d[m[K() {}
      |                [01;36m[K^~~~~~[m[K
[01m[K/usr/include/kdl/utilities/rall2d.h:62:16:[m[K [01;36m[Knote: [m[K  candidate expects 0 arguments, 3 provided
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:29[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/jntarrayvel.hpp:[m[K At global scope:
[01m[K/usr/include/kdl/jntarrayvel.hpp:33:75:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   33 | bool Equal(const JntArrayVel& src1,const JntArrayVel& src2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                       [01;31m[K^~~~~~~[m[K

[01m[K/usr/include/kdl/jntarrayvel.hpp:33:75:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/usr/include/kdl/chainfksolver.hpp:30[m[K,
                 from [01m[K/usr/include/kdl/chainfksolverpos_recursive.hpp:25[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:48[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/kdl/jntarrayacc.hpp:34:75:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[Kepsilon[m[Kâ€™ was not declared in this scope
   34 | bool Equal(const JntArrayAcc& src1,const JntArrayAcc& src2,double eps=[01;31m[Kepsilon[m[K);
      |                                                                       [01;31m[K^~~~~~~[m[K

[01m[K/usr/include/kdl/jntarrayacc.hpp:34:75:[m[K [01;36m[Knote: [m[Ksuggested alternatives:
In file included from [01m[K/usr/include/boost/math/policies/error_handling.hpp:22[m[K,
                 from [01m[K/usr/include/boost/math/special_functions/round.hpp:14[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/time.h:58[m[K,
                 from [01m[K/opt/ros/noetic/include/ros/ros.h:38[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:5[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/usr/include/boost/math/tools/precision.hpp:247:31:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::epsilon[m[Kâ€™
  247 | inline BOOST_MATH_CONSTEXPR T [01;36m[Kepsilon[m[K(BOOST_MATH_EXPLICIT_TEMPLATE_TYPE_SPEC(T)) BOOST_MATH_NOEXCEPT(T)
      |                               [01;36m[K^~~~~~~[m[K
[01m[K/usr/include/boost/math/tools/precision.hpp:181:10:[m[K [01;36m[Knote: [m[K  â€˜[01m[Kboost::math::tools::detail::epsilon[m[Kâ€™
  181 | inline T [01;36m[Kepsilon[m[K(const mpl::false_& BOOST_MATH_APPEND_EXPLICIT_TEMPLATE_TYPE(T))
      |          [01;36m[K^~~~~~~[m[K
In file included from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:81:31:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KState[m[Kâ€™ does not name a type
   81 |                         const [01;31m[KState[m[K& desired_state,
      |                               [01;31m[K^~~~~[m[K
[01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:82:31:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KState[m[Kâ€™ does not name a type
   82 |                         const [01;31m[KState[m[K& state_error );
      |                               [01;31m[K^~~~~[m[K
In file included from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:159[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.hpp:76:53:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KState[m[Kâ€™ does not name a type
   76 |                                               const [01;31m[KState[m[K& desired_state,
      |                                                     [01;31m[K^~~~~[m[K
[01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.hpp:77:53:[m[K [01;31m[Kerror: [m[Kâ€˜[01m[KState[m[Kâ€™ does not name a type
   77 |                                               const [01;31m[KState[m[K& state_error ){
      |                                                     [01;31m[K^~~~~[m[K
[01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.hpp:[m[K In member function â€˜[01m[Kvoid controller_ns::computed_torque_controller_class::update(const ros::Time&, const ros::Duration&, const int&, const int&)[m[Kâ€™:
[01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.hpp:88:42:[m[K [01;31m[Kerror: [m[Krequest for member â€˜[01m[Kacceleration[m[Kâ€™ in â€˜[01m[Kdesired_state[m[Kâ€™, which is of non-class type â€˜[01m[Kconst int[m[Kâ€™
   88 |       desired.qdotdot(i) = desired_state.[01;31m[Kacceleration[m[K[i];
      |                                          [01;31m[K^~~~~~~~~~~~[m[K
[01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.hpp:90:32:[m[K [01;31m[Kerror: [m[Krequest for member â€˜[01m[Kposition[m[Kâ€™ in â€˜[01m[Kstate_error[m[Kâ€™, which is of non-class type â€˜[01m[Kconst int[m[Kâ€™
   90 |       error.q(i) = state_error.[01;31m[Kposition[m[K[i];
      |                                [01;31m[K^~~~~~~~[m[K
[01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.hpp:91:35:[m[K [01;31m[Kerror: [m[Krequest for member â€˜[01m[Kvelocity[m[Kâ€™ in â€˜[01m[Kstate_error[m[Kâ€™, which is of non-class type â€˜[01m[Kconst int[m[Kâ€™
   91 |       error.qdot(i) = state_error.[01;31m[Kvelocity[m[K[i];
      |                                   [01;31m[K^~~~~~~~[m[K
[01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.hpp:118:9:[m[K [01;31m[Kerror: [m[Kexpected â€˜[01m[K,[m[Kâ€™ or â€˜[01m[K;[m[Kâ€™ before â€˜[01m[Kif[m[Kâ€™
  118 |         [01;31m[Kif[m[K(!std::isnan(command))
      |         [01;31m[K^~[m[K
In file included from [01m[K/opt/ros/noetic/include/class_loader/class_loader_core.hpp:45[m[K,
                 from [01m[K/opt/ros/noetic/include/class_loader/class_loader.hpp:46[m[K,
                 from [01m[K/opt/ros/noetic/include/pluginlib/./class_list_macros.hpp:40[m[K,
                 from [01m[K/opt/ros/noetic/include/pluginlib/class_list_macros.h:35[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:2[m[K:
/opt/ros/noetic/include/class_loader/meta_object.hpp: In instantiation of â€˜[01m[KB* class_loader::impl::MetaObject<C, B>::create() const [with C = controller_ns::computed_torque_controller_class; B = controller_interface::ControllerBase][m[Kâ€™:
[01m[K/opt/ros/noetic/include/class_loader/meta_object.hpp:196:7:[m[K   required from here
[01m[K/opt/ros/noetic/include/class_loader/meta_object.hpp:198:12:[m[K [01;31m[Kerror: [m[Kinvalid new-expression of abstract class type â€˜[01m[Kcontroller_ns::computed_torque_controller_class[m[Kâ€™
  198 |     return [01;31m[Knew C[m[K;
      |            [01;31m[K^~~~~[m[K
In file included from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:75:11:[m[K [01;36m[Knote: [m[K  because the following virtual functions are pure within â€˜[01m[Kcontroller_ns::computed_torque_controller_class[m[Kâ€™:
   75 |     class [01;36m[Kcomputed_torque_controller_class[m[K : public controller_interface::Controller<hardware_interface::EffortJointInterface> {
      |           [01;36m[K^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~[m[K
In file included from [01m[K/opt/ros/noetic/include/controller_interface/controller.h:35[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/include/computed_torque/computed_torque_controller.h:24[m[K,
                 from [01m[K/home/sheila/march/ros1/src/control/computed_torque/src/computed_torque_controller.cpp:5[m[K:
[01m[K/opt/ros/noetic/include/controller_interface/controller_base.h:73:16:[m[K [01;36m[Knote: [m[K	â€˜[01m[Kvirtual void controller_interface::ControllerBase::update(const ros::Time&, const ros::Duration&)[m[Kâ€™
   73 |   virtual void [01;36m[Kupdate[m[K(const ros::Time& time, const ros::Duration& period) = 0;
      |                [01;36m[K^~~~~~[m[K
make[2]: *** [CMakeFiles/computed_torque_lib.dir/build.make:63: CMakeFiles/computed_torque_lib.dir/src/computed_torque_controller.cpp.o] Error 1
make[1]: *** [CMakeFiles/Makefile2:265: CMakeFiles/computed_torque_lib.dir/all] Error 2
make: *** [Makefile:141: all] Error 2
